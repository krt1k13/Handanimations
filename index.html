<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hand Controlled 3D Particle Solar System</title>

  <!-- ===== CSS ===== -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.75);
      padding: 12px;
      border-radius: 8px;
      color: white;
      z-index: 10;
      width: 220px;
    }

    #ui h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #ui select, #ui input {
      width: 100%;
      margin-bottom: 10px;
    }

    #video {
      display: none;
    }
  </style>
</head>

<body>
  <!-- UI PANEL -->
  <div id="ui">
    <h3>Control Panel</h3>
    <label>Template</label>
    <select id="template">
      <option value="solar">Solar System</option>
      <option value="heart">Heart</option>
      <option value="flower">Flower</option>
      <option value="sacred">Sacred Symbol</option>
    </select>

    <label>Particle Color</label>
    <input type="color" id="color" value="#00ffff">
  </div>

  <video id="video" autoplay playsinline></video>

  <!-- ===== LIBRARIES ===== -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <!-- ===== MAIN SCRIPT ===== -->
  <script>
    /* ============================
       SCENE SETUP
    ============================ */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.z = 40;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light = new THREE.PointLight(0xffffff, 2);
    light.position.set(50, 50, 50);
    scene.add(light);

    /* ============================
       AUDIO REACTIVE
    ============================ */
    let audioLevel = 0;
    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
      const ctx = new AudioContext();
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 256;
      const source = ctx.createMediaStreamSource(stream);
      source.connect(analyser);

      const data = new Uint8Array(analyser.frequencyBinCount);

      function audioLoop() {
        analyser.getByteFrequencyData(data);
        audioLevel = data.reduce((a,b)=>a+b,0)/data.length/255;
        requestAnimationFrame(audioLoop);
      }
      audioLoop();
    });

    /* ============================
       OBJECT CONTAINERS
    ============================ */
    let currentGroup = new THREE.Group();
    scene.add(currentGroup);

    let particles;

    const loader = new THREE.TextureLoader();
    const earthTex = loader.load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg");
    const saturnTex = loader.load("https://threejs.org/examples/textures/planets/saturn.jpg");

    /* ============================
       TEMPLATES
    ============================ */
    function clearGroup() {
      scene.remove(currentGroup);
      currentGroup = new THREE.Group();
      scene.add(currentGroup);
    }

    function createSolarSystem() {
      clearGroup();

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(3, 64, 64),
        new THREE.MeshStandardMaterial({ map: earthTex })
      );

      const saturn = new THREE.Mesh(
        new THREE.SphereGeometry(4, 64, 64),
        new THREE.MeshStandardMaterial({ map: saturnTex })
      );
      saturn.position.x = 12;

      const ring = new THREE.Mesh(
        new THREE.RingGeometry(5, 7, 64),
        new THREE.MeshBasicMaterial({ color: 0xaa8844, side: THREE.DoubleSide })
      );
      ring.rotation.x = Math.PI / 2;
      saturn.add(ring);

      currentGroup.add(earth, saturn);
    }

    function createParticles(shape) {
      clearGroup();
      const geometry = new THREE.BufferGeometry();
      const count = 5000;
      const positions = [];

      for (let i = 0; i < count; i++) {
        let x,y,z;

        if (shape === "heart") {
          const t = Math.random() * Math.PI * 2;
          x = 16 * Math.pow(Math.sin(t),3);
          y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
          z = (Math.random()-0.5)*5;
        }
        else if (shape === "flower") {
          const r = Math.random()*10;
          const a = Math.random()*Math.PI*2;
          x = r*Math.cos(a);
          y = r*Math.sin(a);
          z = Math.sin(a*6)*3;
        }
        else {
          const a = Math.random()*Math.PI*2;
          const r = Math.random()*10;
          x = Math.cos(a)*r;
          y = Math.sin(a)*r;
          z = Math.sin(a*8)*2;
        }

        positions.push(x,y,z);
      }

      geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
      const material = new THREE.PointsMaterial({ size: 0.15, color: document.getElementById("color").value });
      particles = new THREE.Points(geometry, material);
      currentGroup.add(particles);
    }

    /* ============================
       HAND TRACKING
    ============================ */
    let handDistance = 1;
    let fistClosed = false;

    const hands = new Hands({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults(results => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
        const a = results.multiHandLandmarks[0][0];
        const b = results.multiHandLandmarks[1][0];
        handDistance = Math.hypot(a.x-b.x, a.y-b.y)*5;
      }

      if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
        const thumb = results.multiHandLandmarks[0][4];
        const index = results.multiHandLandmarks[0][8];
        fistClosed = Math.hypot(thumb.x-index.x, thumb.y-index.y) < 0.05;
      }
    });

    const cameraFeed = new Camera(document.getElementById("video"), {
      onFrame: async () => await hands.send({ image: document.getElementById("video") }),
      width: 640,
      height: 480
    });
    cameraFeed.start();

    /* ============================
       UI EVENTS
    ============================ */
    document.getElementById("template").onchange = e => {
      if (e.target.value === "solar") createSolarSystem();
      else createParticles(e.target.value);
    };

    document.getElementById("color").oninput = e => {
      if (particles) particles.material.color.set(e.target.value);
    };

    createSolarSystem();

    /* ============================
       ANIMATION LOOP
    ============================ */
    function animate() {
      requestAnimationFrame(animate);

      currentGroup.scale.setScalar(1 + handDistance);

      if (fistClosed) currentGroup.rotation.y += 0.05;
      else currentGroup.rotation.y += 0.005;

      if (particles) particles.scale.setScalar(1 + audioLevel*2);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
  </script>
</body>
</html>

